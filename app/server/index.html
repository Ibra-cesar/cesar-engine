<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Engine Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            align-items: start;
        }
        
        .board-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .controls {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #8B4513;
            border: 4px solid #8B4513;
            border-radius: 10px;
            overflow: hidden;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            aspect-ratio: 1;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .square:hover {
            transform: scale(0.95);
        }
        
        .square.light {
            background: #f0d9b5;
        }
        
        .square.dark {
            background: #b58863;
        }
        
        .square.selected {
            background: #7fff00 !important;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        
        .square.possible-move {
            background: linear-gradient(135deg, #90EE90, #32CD32) !important;
        }
        
        .square.last-move {
            background: linear-gradient(135deg, #FFD700, #FFA500) !important;
        }
        
        .coordinates {
            position: absolute;
            font-size: 0.8rem;
            color: #666;
        }
        
        .rank {
            top: 2px;
            left: 2px;
        }
        
        .file {
            bottom: 2px;
            right: 2px;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: monospace;
        }
        
        .move-history {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .status.white-turn {
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            color: #2c3e50;
        }
        
        .status.black-turn {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
        }
        
        .engine-response {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .chessboard {
                max-width: 350px;
            }
            
            .square {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <h1>Chess Engine Tester</h1>
            <div class="status white-turn" id="gameStatus">White to move</div>
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Quick Moves</h3>
                <input type="text" id="moveInput" placeholder="Enter move (e.g., e2e4)" />
                <button onclick="makeMove()">Make Move</button>
                <button onclick="undoMove()" class="btn-secondary">Undo Move</button>
            </div>
            
            <div class="control-group">
                <h3>Board Setup</h3>
                <textarea id="fenInput" placeholder="Enter FEN string (optional)">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</textarea>
                <button onclick="loadFEN()">Load Position</button>
                <button onclick="resetBoard()" class="btn-secondary">Reset Board</button>
            </div>
            
            <div class="control-group">
                <h3>Engine Communication</h3>
                <textarea id="engineCommand" placeholder="Enter command for engine"></textarea>
                <button onclick="sendCommand()">Send to Engine</button>
                <div id="engineResponse"></div>
            </div>
            
            <div class="control-group">
                <h3>Move History</h3>
                <div class="move-history" id="moveHistory">Game started</div>
                <button onclick="clearHistory()" class="btn-danger">Clear History</button>
            </div>
            
            <div class="control-group">
                <h3>Export/Import</h3>
                <button onclick="exportPGN()" class="btn-secondary">Export PGN</button>
                <button onclick="copyFEN()" class="btn-secondary">Copy FEN</button>
            </div>
        </div>
    </div>

    <script>
        class ChessClient {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.lastMove = null;
                this.initializeUI();
            }
            
            initializeBoard() {
                return [
                    ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                    ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                    ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
                ];
            }
            
            initializeUI() {
                this.renderBoard();
                this.updateStatus();
                
                document.getElementById('moveInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.makeMove();
                });
            }
            
            renderBoard() {
                const boardElement = document.getElementById('chessboard');
                boardElement.innerHTML = '';
                
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const square = document.createElement('div');
                        square.className = `square ${(rank + file) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.rank = rank;
                        square.dataset.file = file;
                        
                        if (this.board[rank][file]) {
                            square.textContent = this.board[rank][file];
                        }
                        
                        // Add coordinates
                        if (file === 0) {
                            const rankLabel = document.createElement('span');
                            rankLabel.className = 'coordinates rank';
                            rankLabel.textContent = 8 - rank;
                            square.appendChild(rankLabel);
                        }
                        if (rank === 7) {
                            const fileLabel = document.createElement('span');
                            fileLabel.className = 'coordinates file';
                            fileLabel.textContent = String.fromCharCode(97 + file);
                            square.appendChild(fileLabel);
                        }
                        
                        square.addEventListener('click', () => this.handleSquareClick(rank, file));
                        boardElement.appendChild(square);
                    }
                }
                
                this.highlightSquares();
            }
            
            handleSquareClick(rank, file) {
                const square = document.querySelector(`[data-rank="${rank}"][data-file="${file}"]`);
                
                if (this.selectedSquare) {
                    if (this.selectedSquare.rank === rank && this.selectedSquare.file === file) {
                        // Deselect
                        this.selectedSquare = null;
                    } else {
                        // Try to make a move
                        const from = this.squareToNotation(this.selectedSquare.rank, this.selectedSquare.file);
                        const to = this.squareToNotation(rank, file);
                        const moveStr = from + to;
                        
                        if (this.isValidMove(moveStr)) {
                            this.executeMove(moveStr);
                            this.selectedSquare = null;
                        } else {
                            // Select new square
                            this.selectedSquare = {rank, file};
                        }
                    }
                } else {
                    // Select square
                    this.selectedSquare = {rank, file};
                }
                
                this.renderBoard();
            }
            
            squareToNotation(rank, file) {
                return String.fromCharCode(97 + file) + (8 - rank);
            }
            
            notationToSquare(notation) {
                const file = notation.charCodeAt(0) - 97;
                const rank = 8 - parseInt(notation[1]);
                return {rank, file};
            }
            
            isValidMove(moveStr) {
                // Basic validation - you can enhance this
                if (moveStr.length !== 4) return false;
                
                const from = this.notationToSquare(moveStr.substring(0, 2));
                const to = this.notationToSquare(moveStr.substring(2, 4));
                
                // Check if squares are valid
                if (from.rank < 0 || from.rank > 7 || from.file < 0 || from.file > 7) return false;
                if (to.rank < 0 || to.rank > 7 || to.file < 0 || to.file > 7) return false;
                
                // Check if there's a piece on the from square
                return this.board[from.rank][from.file] !== null;
            }
            
            executeMove(moveStr) {
                const from = this.notationToSquare(moveStr.substring(0, 2));
                const to = this.notationToSquare(moveStr.substring(2, 4));
                
                // Store move for history
                const piece = this.board[from.rank][from.file];
                const capturedPiece = this.board[to.rank][to.file];
                
                // Make the move
                this.board[to.rank][to.file] = this.board[from.rank][from.file];
                this.board[from.rank][from.file] = null;
                
                // Update game state
                this.lastMove = {from: moveStr.substring(0, 2), to: moveStr.substring(2, 4)};
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Add to history
                const moveNumber = Math.ceil((this.moveHistory.length + 1) / 2);
                const moveNotation = this.currentPlayer === 'black' ? 
                    `${moveNumber}. ${moveStr}` : `${moveStr}`;
                
                this.moveHistory.push({
                    notation: moveStr,
                    piece: piece,
                    captured: capturedPiece,
                    from: from,
                    to: to
                });
                
                this.updateMoveHistory();
                this.updateStatus();
                
                // Simulate engine response
                this.simulateEngineResponse(moveStr);
            }
            
            simulateEngineResponse(move) {
                const responses = [
                    `Move received: ${move}`,
                    `Evaluating position...`,
                    `Position evaluation: +0.3`,
                    `Best move calculated: d7d5`,
                    `Thinking depth: 6 ply`
                ];
                
                const response = responses[Math.floor(Math.random() * responses.length)];
                this.addEngineResponse(response);
            }
            
            addEngineResponse(response) {
                const container = document.getElementById('engineResponse');
                const div = document.createElement('div');
                div.className = 'engine-response';
                div.textContent = new Date().toLocaleTimeString() + ': ' + response;
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }
            
            highlightSquares() {
                // Highlight selected square
                if (this.selectedSquare) {
                    const square = document.querySelector(
                        `[data-rank="${this.selectedSquare.rank}"][data-file="${this.selectedSquare.file}"]`
                    );
                    if (square) square.classList.add('selected');
                }
                
                // Highlight last move
                if (this.lastMove) {
                    const fromSquare = this.notationToSquare(this.lastMove.from);
                    const toSquare = this.notationToSquare(this.lastMove.to);
                    
                    const fromElement = document.querySelector(
                        `[data-rank="${fromSquare.rank}"][data-file="${fromSquare.file}"]`
                    );
                    const toElement = document.querySelector(
                        `[data-rank="${toSquare.rank}"][data-file="${toSquare.file}"]`
                    );
                    
                    if (fromElement) fromElement.classList.add('last-move');
                    if (toElement) toElement.classList.add('last-move');
                }
            }
            
            updateStatus() {
                const status = document.getElementById('gameStatus');
                status.textContent = `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} to move`;
                status.className = `status ${this.currentPlayer}-turn`;
            }
            
            updateMoveHistory() {
                const historyElement = document.getElementById('moveHistory');
                const history = this.moveHistory.map((move, index) => {
                    const moveNum = Math.floor(index / 2) + 1;
                    const isWhite = index % 2 === 0;
                    return isWhite ? `${moveNum}. ${move.notation}` : ` ${move.notation}`;
                }).join('');
                
                historyElement.textContent = history || 'Game started';
            }
            
            loadFEN(fen) {
                // Basic FEN loading (you can enhance this)
                if (!fen) fen = document.getElementById('fenInput').value;
                if (!fen) return;
                
                const parts = fen.split(' ');
                const position = parts[0];
                
                // Clear board
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Parse position
                const ranks = position.split('/');
                for (let rank = 0; rank < 8; rank++) {
                    let file = 0;
                    for (const char of ranks[rank]) {
                        if (char >= '1' && char <= '8') {
                            file += parseInt(char);
                        } else {
                            this.board[rank][file] = this.fenToPiece(char);
                            file++;
                        }
                    }
                }
                
                this.currentPlayer = parts[1] === 'w' ? 'white' : 'black';
                this.renderBoard();
                this.updateStatus();
            }
            
            fenToPiece(char) {
                const pieces = {
                    'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                    'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
                };
                return pieces[char] || null;
            }
            
            reset() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.lastMove = null;
                this.renderBoard();
                this.updateStatus();
                this.updateMoveHistory();
            }
        }
        
        // Initialize the chess client
        const chessClient = new ChessClient();
        
        // Global functions for buttons
        function makeMove() {
            const moveInput = document.getElementById('moveInput');
            const move = moveInput.value.trim().toLowerCase();
            
            if (chessClient.isValidMove(move)) {
                chessClient.executeMove(move);
                moveInput.value = '';
            } else {
                alert('Invalid move format. Use notation like: e2e4');
            }
        }
        
        function undoMove() {
            // Basic undo functionality
            if (chessClient.moveHistory.length > 0) {
                const lastMove = chessClient.moveHistory.pop();
                
                // Restore position
                chessClient.board[lastMove.from.rank][lastMove.from.file] = lastMove.piece;
                chessClient.board[lastMove.to.rank][lastMove.to.file] = lastMove.captured;
                
                chessClient.currentPlayer = chessClient.currentPlayer === 'white' ? 'black' : 'white';
                chessClient.selectedSquare = null;
                chessClient.lastMove = chessClient.moveHistory.length > 0 ? 
                    chessClient.moveHistory[chessClient.moveHistory.length - 1] : null;
                
                chessClient.renderBoard();
                chessClient.updateStatus();
                chessClient.updateMoveHistory();
            }
        }
        
        function loadFEN() {
            chessClient.loadFEN();
        }
        
        function resetBoard() {
            chessClient.reset();
        }
        
        function sendCommand() {
            const command = document.getElementById('engineCommand').value;
            if (command.trim()) {
                chessClient.addEngineResponse(`Command sent: ${command}`);
                // Here you would send the command to your actual engine
                document.getElementById('engineCommand').value = '';
            }
        }
        
        function clearHistory() {
            document.getElementById('engineResponse').innerHTML = '';
        }
        
        function exportPGN() {
            const moves = chessClient.moveHistory.map(move => move.notation).join(' ');
            const pgn = `[Event "Test Game"]\n[Date "${new Date().toISOString().split('T')[0]}"]\n\n${moves}`;
            
            const blob = new Blob([pgn], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'game.pgn';
            a.click();
        }
        
        function copyFEN() {
            // Generate current FEN (simplified)
            const fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; // placeholder
            navigator.clipboard.writeText(fen).then(() => {
                alert('FEN copied to clipboard!');
            });
        }
    </script>
</body>
</html>
